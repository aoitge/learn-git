# **我的 Git 学习笔记 (第一天)**

**今日目标：** 完成 Git 的初始配置，并完全掌握在**本地**对项目进行版本控制的**核心工作循环**。

## 第〇步：准备工作与环境配置

这是我们开始 Git 之旅的第一步，确保我们的工具已经就绪并且“认识”我们。

### 1. 检查 Git 版本

- **命令:**
  ```bash
  git --version
  ```
- **它是什么：** 检查电脑上安装的 Git 版本。
- **它为什么重要：** 确认 Git 已被正确安装，可以开始使用。我们的版本是 `2.49.0`，非常新。

### 2. 设置全局身份

- **命令:**
  ```bash
  git config --global user.name "Gzito"
  git config --global user.email "gjm13635248896@gmail.com"
  ```
- **它是什么：** 设置你在这个电脑上所有 Git 仓库的“作者签名”。`--global` 意味着这是全局配置，一劳永逸。
- **它为什么重要：** 这是 Git 世界的“实名制”。你未来的每一次提交（commit）都会用这个名字和邮箱来署名。这是为了**追溯历史**和**团队协作**，让所有人知道每一次改动是谁做的。

## 第一步：核心概念的理解

在敲下第一个命令之前，我们先理解了 Git 的设计哲学。

- **我遇到的问题：** “书上没讲什么是‘分布式版本控制’，这是什么意思？”
- **你的解答 (图书馆比喻)：**
  > **中心化 (如 SVN)** 就像一个城市的**总图书馆**。你要改东西，必须先联网去总馆借，改完再还回去。总馆关门了，所有人都干不了活。
  > **分布式 (Git)** 就像是你 `clone` 一个项目时，把整个**图书馆的完整复刻版**（包括所有历史记录）都搬到了你的电脑上。你在本地提交，就是在你自己的“私人图书馆”里操作，完全不需要联网。需要协作时，再把你本地的更新“推送”到 GitHub 这种公共的远程图书馆。
- **学这个有什么用：** 理解了“分布式”，就理解了为什么 Git 的绝大部分操作（commit, log, diff）都飞快无比，而且不依赖网络。这是 Git 最核心的优势。

## 第二步：创建我的第一个仓库

我们在这里，把一个普通的文件夹，变成了一个拥有版本控制能力的 Git 仓库。

### 1. 初始化仓库

- **命令:**
  ```bash
  git init
  ```
- **它是什么：** 在当前目录下创建一个新的 Git 仓库。它会生成一个隐藏的 `.git` 目录。
- **它为什么重要：** 这个 `.git` 目录就是我们之前比喻的“本地图书馆”，它包含了我们项目的所有历史快照和元数据。**它是 Git 的一切核心所在。**

### 2. 分支重命名

- **我遇到的问题：** “我不小心创建了 `master` 分支，但书上推荐用 `main`，怎么改？”
- **命令:**
  ```bash
  git branch -M main
  ```
- **它是什么：** `-M` 强制性地将当前分支重命名为 `main`。
- **它为什么重要：** `main` 是现在业界推荐的默认分支名，这是一种好的实践。

## 第三步：核心工作流：修改 -> 暂存 -> 提交

这是我们今天学习的重点，也是未来使用 Git 90% 的时间在做的事情。

### 核心概念：文件的三种状态与三个区域

- **工作区 (Working Directory):** 你能直接看到的项目文件夹。
- **暂存区 (Staging Area / Index):** 一个临时的存储区域，像一个“购物车”，用来存放你准备在下一次提交中包含的改动。
- **本地仓库 (Local Repository / .git):** 你项目的完整历史数据库。

### 1. `git status` - 你的“仪表盘”

- **命令:** `git status`
- **它是什么：** 随时告诉你工作区和暂存区里每个文件的状态。
- **它为什么重要：** 这是你最常用的命令。它会清晰地告诉你哪些文件是“未跟踪的 (Untracked)”，“已修改待暂存的 (Changes not staged for commit)”，或是“已暂存待提交的 (Changes to be committed)”。

### 2. `git add` - “放入购物车”

- **命令:** `git add <文件名>`
- **它是什么：** 将工作区的修改（新文件或文件的改动）添加到暂存区。
- **它为什么重要：** 这是从“我改了代码”到“我准备提交这些代码”的关键一步。它让你能精确控制哪些修改要被包含在下一次的快照中，从而实现干净、原子的提交。

### 3. `git commit` - “结账，生成快照”

- **命令:** `git commit -m "你的提交信息"`
- **它是什么：** 将暂存区的所有内容生成一个永久性的快照，并保存在本地仓库的历史记录中。
- **它为什么重要：** 这是 Git 的核心目的——创建项目历史。`-m` 后的提交信息至关重要，它是你写给未来自己和同事的“历史日志”。

## 第四步：时光机 - 查看历史与撤销操作

我们不仅要会前进，更要会回顾和“后悔”。

### 1. `git log` - 查看历史记录

- **我遇到的问题：** “`git log` 只能看到提交信息，怎么看每次提交改了哪些文件？”
- **命令:**
  - `git log --stat`: 查看每次提交的**文件统计信息**。
  - `git log -p`: 查看每次提交的**具体代码改动**（补丁）。
- **它为什么重要：** 让你能清晰地回顾项目的演进过程，追踪每一次变更的细节。

### 2. `git diff` - 我到底改了什么？

- **命令:**
  - `git diff`: 查看**工作区** vs **暂存区**的差异。
  - `git diff --staged`: 查看**暂存区** vs **上次提交 (HEAD)** 的差异。
- **它为什么重要：** 让你在提交前能精确地检查自己的修改，确保不会提交错误或多余的代码。

### 3. 后悔药 1：撤销操作 (`git restore`)

- **我遇到的问题：** “`git restore` 好像没起作用？文件内容还在。”
- **你的解答：** 这是因为文件当时是**未跟踪 (untracked)** 状态。`restore` 命令主要作用于**已跟踪**的文件。在我们完成一次 `commit` 让文件被跟踪后，一切就正常了。
- **命令:**
  - `git restore --staged <文件名>`: **撤销暂存**。把文件从暂存区拿回来，但保留工作区的修改。
  - `git restore <文件名>`: **彻底撤销工作区的修改**。让文件恢复到和上次提交时一模一样的状态（危险操作！）。
- **学这个有什么用：** 让你能轻松应对“add错文件”或“写错代码想放弃”的场景。

### 4. 后悔药 2：修正最后一次提交 (`git commit --amend`)

- **命令:** `git commit --amend`
- **它是什么：** 一个强大的“修正”工具。它**不会创建新的提交**，而是让你**修改最后一次提交**，可以同时补充忘记 `add` 的文件和修改提交信息。
- **它为什么重要：** 能让你的提交历史保持整洁、专业，避免因为小错误（如拼写错误）而产生大量琐碎的修正提交。

---

**今日总结：** 我已经成功地在本地建立了一个 Git 仓库，并熟练掌握了 `add`, `commit`, `log`, `status`, `diff`, `restore`, `amend` 等核心命令。我已经准备好明天学习更高级的分支操作了！

